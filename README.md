Suave.io Pollz Tutorial
=======================

[![Deploy to Azure](http://azuredeploy.net/deploybutton.png)](https://azuredeploy.net/)
[![Deploy to Heroku](https://www.herokucdn.com/deploy/button.png)](https://heroku.com/deploy)

In this tutorial, you'll build a simple polling web site. The site shows a
number of polls (specified in JSON files), lets users vote in the polls
(checking that they vote only once using a cookie) and displays the results
of polls (using a chart).

This directory contains the following important files and sub-directories:

 * **Data folder** contains the data; `data/votes.json` stores the votes
   for all the polls and `data/polls/*.json` is the specification of all the
   poll questions and answers. (In a real project, you could keep those in
   a document database or a blob storage, but filesystem will do for us!)

 * **Templates folder** - we are using DotLiquid for templating. The
   `templates` folder contains `*.html` files which are DotLiquid templates.

 * **Code folder** contains most of the source code; `data.fs` is the data
   access layer and the three other files (`home.fs`, `results.fs` and
   `vote.fs`) implement three Suave web parts for the home page, results
   display and the voting page.

 * **App script** - the `app.fsx` file in the top-level is the entry point that
   loads all the other files in the `code` folder and composes the main
   `app` value. This is then hosted on Azure/Heroku or locally.

 * **Build scripts** - to start the web site, run `build.sh` or `build.cmd`
   depending on your operating system! You can also open the `fsproj` file in
   Visual Studio or Xamarin Studio (if you want to use the debugger).

To solve the tasks in this tutorial, you'll only need to modify the files in
the `templates` folder (to specify the HTML that should be generated) and in
the `code` folder (to actually implement the F# back-end :-)).

Implementing a simple poll site
-------------------------------

In the first part, you'll implement the basics - displaying data on the home
page, displaying poll results and voting. Along the way, you'll add a few
reusable functions for data access into `data.fs` using the JSON type provider.

### Step 1: Displaying the home page
To display the right polls on the home page, go to `home.fs` and
complete Step 1 (loading of poll information from JSON data files).
Then have a look at `home.html` to understand how the DotLiquid
template works!

### Step 2: Displaying the results page
Display the results of the polls. To do this, you'll need to go to `data.fs` and
implement loading of votes and polls. Once you create a global value `votes` and
functions `loadPoll` & `loadVotes`, you can move to `results.fs` and implement
the view part of the page.

### Step 3: Displaying the voting page
Next, we need to generate a page to display the voting option. To do this, go to
`votes.fs`. Given a poll "foo", with two options, we need to generate a page with 
links to `/vote/foo/0` and `/vote/foo/1`. To do this, you'll need to define
the model (`Option` and `Poll` types), implement the `getOptions` function
and also modify `vote.html` page in `templates` to generate the right HTML.
 
### Step 4: Implement the actual voting
The final step is to actually update the votes! To do this, we'll start by simply
making the `votes` in `data.fs` a mutable variable (it is still an immutable
map and we'll turn it into agent later). Then you can implement `castVote` in
`data.fs` and go back to `vote.fs` to implement handler for the URLs of the 
form `/vote/foo/0`. After voting, user should be redirected to `/results/foo`.


Optional features to add
------------------------

There is a number of other features that you could add to the application. Once
you get here, you can do the remaining features in any order, so feel free to 
skip the boring ones and do the more interesting ones!

### Step 5: Save the votes to JSON
After casting votes, we want to save the new data to `votesFile` so that it 
does not get lost during restart. To do that, implement the `saveVotes` function
which saves the `Votes` data structure into JSON using the types generated by 
the JSON type provider.

### Step 6: Show the results in a chart!
It is surprisingly easy to add a Pie or Bar chart showing the results using 
Google charts. You'll need to change `results.fs` and use the XPlot library
to draw the chart. This gives you inline HTML that you can add to the model
and then display in `results.html`.

### Step 7: Blocking repeated voting with cookies
This might not be the best protection, but better than nothing!
After user votes, we set a cookie with the name of the poll. When they
try to vote, we check cookies and if they already have the cookie, we
redirect them directly to results. Go to `votes.fs` to add this!

### Step 8: Sorting polls on the home page

It would be nice if more popular polls appeared at the top of the home page.
To do this, we can sort the polls by the total number of votes inside
`home.fs`. You'll need to go to `home.fs`, add a field `Votes` of type `int`
to the `Poll` type and use it to sort the data. Then you can also modify
`home.html` to display the total number of votes in the poll on the home page. 

Ideas for even more features
----------------------------

There is a lot of other features that you can add to the web site! There are no
more hints in the source code, but you learned enough to be able to continue
on your own. In doubt, you can find more information on [suave.io](http://suave.io)!

### Multi-choice polls
For some polls, it makes sense to choose multiple options. To support this, 
you'll need to change the voting page so that it generates HTML `<form>` with 
radio buttons or check boxes. You'll also need to adapt the request handling to 
read data from the form.
   
### User interface for creating polls
Another nice feature would be to let the users to create new polls. To do this,
you'll need to add a new page and a new template file. You can again use a 
basic `<form>` to enter the possible answers.
 
### Support open answers
For some polls, it makes sense to allow the user to enter arbitrary text. Add 
a Boolean option to some part of the JSON files in `data/polls`. When it is 
set, generate a text box on the voting page, store the results in `data/votes.json` 
and display the optional text answers in the `results.html` page.
